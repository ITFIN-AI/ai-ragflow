{"version":3,"file":"5176.525ce481.async.js","mappings":"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","sources":["webpack:///./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js","webpack:///./node_modules/@tanstack/react-query/build/modern/isRestoring.js","webpack:///./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js","webpack:///./node_modules/@tanstack/react-query/build/modern/suspense.js","webpack:///./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js","webpack:///./node_modules/@tanstack/react-query/node_modules/@tanstack/query-core/build/modern/mutationObserver.js","webpack:///./node_modules/@tanstack/react-query/build/modern/useMutation.js","webpack:///./node_modules/@tanstack/react-query/build/modern/useQuery.js","webpack:///./node_modules/@tanstack/react-query/build/modern/utils.js","webpack:///./node_modules/@tanstack/react-query/node_modules/@tanstack/query-core/build/modern/queryObserver.js"],"sourcesContent":["\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","\"use client\";\n\n// src/isRestoring.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=isRestoring.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"./utils.js\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.throwOnError) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureStaleTime = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    if (typeof defaultedOptions.staleTime !== \"number\") {\n      defaultedOptions.staleTime = 1e3;\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { notifyManager } from \"@tanstack/query-core\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from \"./suspense.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, isRestoring]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions, { listeners: false });\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: client.getQueryCache().get(defaultedOptions.queryHash)\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","// src/mutationObserver.ts\nimport { getDefaultState } from \"./mutation.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { hashKey, shallowEqualObjects } from \"./utils.js\";\nvar MutationObserver = class extends Subscribable {\n  #client;\n  #currentResult = void 0;\n  #currentMutation;\n  #mutateOptions;\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.#updateResult();\n  }\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.#client.defaultMutationOptions(options);\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: \"observerOptionsUpdated\",\n        mutation: this.#currentMutation,\n        observer: this\n      });\n    }\n    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {\n      this.reset();\n    } else if (this.#currentMutation?.state.status === \"pending\") {\n      this.#currentMutation.setOptions(this.options);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this);\n    }\n  }\n  onMutationUpdate(action) {\n    this.#updateResult();\n    this.#notify(action);\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  reset() {\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = void 0;\n    this.#updateResult();\n    this.#notify();\n  }\n  mutate(variables, options) {\n    this.#mutateOptions = options;\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);\n    this.#currentMutation.addObserver(this);\n    return this.#currentMutation.execute(variables);\n  }\n  #updateResult() {\n    const state = this.#currentMutation?.state ?? getDefaultState();\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === \"pending\",\n      isSuccess: state.status === \"success\",\n      isError: state.status === \"error\",\n      isIdle: state.status === \"idle\",\n      mutate: this.mutate,\n      reset: this.reset\n    };\n  }\n  #notify(action) {\n    notifyManager.batch(() => {\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables;\n        const context = this.#currentResult.context;\n        if (action?.type === \"success\") {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context);\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context);\n        } else if (action?.type === \"error\") {\n          this.#mutateOptions.onError?.(action.error, variables, context);\n          this.#mutateOptions.onSettled?.(\n            void 0,\n            action.error,\n            variables,\n            context\n          );\n        }\n      }\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult);\n      });\n    });\n  }\n};\nexport {\n  MutationObserver\n};\n//# sourceMappingURL=mutationObserver.js.map","\"use client\";\n\n// src/useMutation.ts\nimport * as React from \"react\";\nimport { MutationObserver, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { noop, shouldThrowError } from \"./utils.js\";\nfunction useMutation(options, queryClient) {\n  const client = useQueryClient(queryClient);\n  const [observer] = React.useState(\n    () => new MutationObserver(\n      client,\n      options\n    )\n  );\n  React.useEffect(() => {\n    observer.setOptions(options);\n  }, [observer, options]);\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  const mutate = React.useCallback(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop);\n    },\n    [observer]\n  );\n  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {\n    throw result.error;\n  }\n  return { ...result, mutate, mutateAsync: result.mutate };\n}\nexport {\n  useMutation\n};\n//# sourceMappingURL=useMutation.js.map","\"use client\";\n\n// src/useQuery.ts\nimport { QueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useQuery(options, queryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient);\n}\nexport {\n  useQuery\n};\n//# sourceMappingURL=useQuery.js.map","// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\nexport {\n  noop,\n  shouldThrowError\n};\n//# sourceMappingURL=utils.js.map","// src/queryObserver.ts\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { fetchState } from \"./query.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(newState.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map"],"names":["createValue","isReset","clearReset","reset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","IsRestoringContext","useIsRestoring","Provider","ensurePreventErrorBoundaryRetry","options","errorResetBoundary","suspense","throwOnError","retryOnMount","useClearResetErrorBoundary","getHasError","result","query","isError","isFetching","error","ensureStaleTime","defaultedOptions","staleTime","shouldSuspend","isPending","fetchOptimistic","observer","catch","useBaseQuery","Observer","queryClient","client","isRestoring","defaultQueryOptions","getDefaultOptions","queries","_experimental_beforeQuery","_optimisticResults","getOptimisticResult","onStoreChange","unsubscribe","subscribe","notifyManager","batchCalls","updateResult","getCurrentResult","setOptions","listeners","getQueryCache","get","queryHash","_experimental_afterQuery","notifyOnChangeProps","trackResult","MutationObserver","constructor","super","this","bindMethods","mutate","bind","prevOptions","defaultMutationOptions","getMutationCache","notify","type","mutation","mutationKey","state","status","onUnsubscribe","hasListeners","removeObserver","onMutationUpdate","action","variables","build","addObserver","execute","isSuccess","isIdle","batch","context","onSuccess","data","onSettled","onError","forEach","listener","useMutation","mutateOptions","mutateAsync","useQuery","shouldThrowError","throwError","params","noop","QueryObserver","Set","refetch","onSubscribe","size","shouldFetchOnMount","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","notifyOptions","prevQuery","enabled","Error","_defaulted","mounted","shouldFetchOptionally","nextRefetchInterval","createResult","optimisticResult","shouldAssignObserverCurrentProperties","onPropTracked","trackedResult","Object","keys","key","defineProperty","configurable","enumerable","trackProp","add","getCurrentQuery","fetch","isFetchingOptimistic","then","fetchOptions","cancelRefetch","promise","isStale","timeout","dataUpdatedAt","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","newState","isPlaceholderData","fetchOnMount","fetchOptionally","fetchStatus","errorUpdatedAt","select","selectError","placeholderData","Date","now","isLoading","hasData","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangePropsValue","includedProps","some","typedKey","has","shouldNotifyListeners","onQueryUpdate","shouldLoadOnMount","refetchOnMount","field","value","isStaleByTime"],"sourceRoot":""}